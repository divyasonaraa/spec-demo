name: Spec Debugger

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  run-debugger:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies (force dev)
        # Force installing devDependencies in case any CI envs set production installs
        env:
          NPM_CONFIG_PRODUCTION: false
        run: |
          npm ci

      - name: Debug Node env and module resolution
        run: |
          echo "### Environment"
          echo "NODE_ENV=${NODE_ENV:-not-set}"
          echo "NPM_CONFIG_PRODUCTION=${NPM_CONFIG_PRODUCTION:-not-set}"
          echo "### Node & npm versions"
          node -e "console.log('node version', process.version)"
          node -e "console.log('npm version', require('child_process').execSync('npm --version').toString().trim())"
          echo "### node_modules listing (top-level)"
          ls -la node_modules | sed -n '1,200p' || true
          echo "### Try resolving tsconfig-paths"
          node -e "try { console.log('tsconfig-paths resolved to', require.resolve('tsconfig-paths')); } catch(e) { console.error('resolve error:', e.message); process.exit(2) }"

      - name: Ensure tsx and tsconfig-paths are available (verify)
        run: |
          # verify tsx (installed via devDependencies or via npx later)
          npx --yes tsx --version || true
          # verify local resolution of tsconfig-paths (fail if not resolvable)
          node -e "try { console.log('tsconfig-paths ok:', require.resolve('tsconfig-paths')); } catch(e) { console.error('tsconfig-paths not resolvable:', e.message); process.exit(2) }"

      - name: Discover TS sample configs
        id: discover
        run: |
          # Find all TypeScript sample files in src/config/samples/
          SAMPLES=$(find src/config/samples -name "*.ts" -type f 2>/dev/null || true)
          if [ -z "$SAMPLES" ]; then
            echo "âš ï¸ No TypeScript samples found in src/config/samples/"
            echo "samples=" >> $GITHUB_OUTPUT
          else
            echo "âœ… Found $(echo "$SAMPLES" | wc -l) sample(s)"
            echo "$SAMPLES" | while read -r f; do
              echo "   - $(basename "$f")"
            done
            echo "samples<<EOF" >> $GITHUB_OUTPUT
            echo "$SAMPLES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Run Debugger on TS samples
        id: run_all
        run: |
          set -euo pipefail

          mkdir -p ci-results
          : > ci-results/summary.txt

          SAMPLES="${{ steps.discover.outputs.samples }}"

          if [ -z "$SAMPLES" ]; then
            echo "No samples to analyze"
            exit 0
          fi

          # Split samples into array by newline (preserves whitespace in filenames carefully)
          IFS=$'\n' read -r -d '' -a SAMPLES_ARR <<<"${SAMPLES}"$'\0'

          EXIT_CODE=0

          for sample in "${SAMPLES_ARR[@]}"; do
            # skip empty lines if any
            if [ -z "$sample" ]; then
              continue
            fi

            echo "============================================"
            echo "Analyzing TS sample: $sample"
            echo "============================================"

            BASENAME=$(basename "$sample" .ts)
            LOGFILE="ci-results/${BASENAME}.log"

            # Run the TS-aware debugger CLI. Use npx to ensure tsx + tsconfig-paths are available
            # and preload tsconfig-paths/register so `paths` in tsconfig work.
            # We capture stdout/stderr into a per-sample log and check exit code explicitly.
            if npx --yes --package tsx --package tsconfig-paths tsx -r tsconfig-paths/register tools/debugger/cli/run-debugger-config.mjs "$sample" > "$LOGFILE" 2>&1; then
              echo "âœ“ $BASENAME: PASSED (no errors)" >> ci-results/summary.txt
            else
              echo "âœ— $BASENAME: FAILED (errors detected)" >> ci-results/summary.txt
              EXIT_CODE=1
              echo "---- last 200 lines of $LOGFILE ----"
              tail -n 200 "$LOGFILE" || true
            fi
          done

          echo "============================================"
          echo "Summary:"
          cat ci-results/summary.txt || true
          echo "============================================"

          if [ "$EXIT_CODE" -eq 1 ]; then
            echo "âŒ One or more configs failed with errors"
            exit 1
          else
            echo "âœ… All configs passed (no errors detected)"
            exit 0
          fi

      - name: Generate detailed summary (direct TS)
        if: always()
        run: |
          node -r tsx/register -r tsconfig-paths/register tools/debugger/ci/generate-summary.mjs
        shell: bash

      - name: Ensure summary exists (fallback)
        if: always()
        run: |
          if [ ! -f summary.md ]; then
            echo "## ðŸ” Spec Debugger Summary" > summary.md
            echo "(generated fallback summary)" >> summary.md
            if [ -f ci-results/summary.txt ]; then
              echo "" >> summary.md
              echo "Results:" >> summary.md
              echo '```text' >> summary.md
              cat ci-results/summary.txt >> summary.md
              echo '```' >> summary.md
            else
              echo "No results found." >> summary.md
            fi
          fi
          echo "== summary.md =="
          sed -n '1,200p' summary.md || true

      - name: Comment summary
        if: always()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: summary.md
